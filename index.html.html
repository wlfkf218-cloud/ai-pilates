<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI 필라테스 루틴 검색기</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111827;
      --card2:#0f172a;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --line:#243045;
      --accent:#7c3aed;
      --accent2:#22c55e;
      --danger:#ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(124,58,237,.25), transparent 60%),
                  radial-gradient(900px 600px at 90% 20%, rgba(34,197,94,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    a{color:inherit; text-decoration:none}
    .wrap{max-width:1100px; margin:0 auto; padding:24px 16px 40px}
    header{
      display:flex; gap:12px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
      margin-bottom:16px;
    }
    .title{
      display:flex; flex-direction:column; gap:6px;
    }
    .title h1{
      margin:0;
      font-size:22px;
      letter-spacing:-.2px;
    }
    .title p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px 14px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      background: rgba(17,24,39,.55);
    }
    .panel-head h2{
      margin:0;
      font-size:14px;
      letter-spacing:-.1px;
    }
    .panel-body{padding:14px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .row + .row{margin-top:12px}
    .field{
      display:flex; flex-direction:column; gap:6px; min-width: 180px;
      flex: 1 1 220px;
    }
    label{font-size:12px; color:var(--muted)}
    input[type="text"], input[type="password"], select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,42,.55);
      color:var(--text);
      outline:none;
    }
    input[type="text"]:focus, input[type="password"]:focus, select:focus{
      border-color: rgba(124,58,237,.7);
      box-shadow: 0 0 0 3px rgba(124,58,237,.18);
    }
    button{
      border:0;
      border-radius: 12px;
      padding:10px 12px;
      background: rgba(124,58,237,.95);
      color:white;
      cursor:pointer;
      font-weight:600;
      letter-spacing:-.1px;
      transition: transform .02s ease, opacity .15s ease;
    }
    button:active{transform: scale(.99)}
    button.secondary{
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      color: var(--text);
      font-weight:600;
    }
    button.danger{
      background: rgba(239,68,68,.95);
    }
    button:disabled{opacity:.55; cursor:not-allowed}
    .pillbar{display:flex; flex-wrap:wrap; gap:8px}
    .pill{
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color: var(--text);
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .pill:hover{border-color: rgba(124,58,237,.55)}
    .pill.on{
      background: rgba(124,58,237,.22);
      border-color: rgba(124,58,237,.65);
    }
    .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.5;
    }
    .status{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,23,42,.45);
      margin-top:12px;
      min-height:42px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(156,163,175,.7);
      box-shadow: 0 0 0 3px rgba(156,163,175,.12);
      flex:0 0 auto;
    }
    .dot.ok{background: rgba(34,197,94,.9); box-shadow: 0 0 0 3px rgba(34,197,94,.16)}
    .dot.bad{background: rgba(239,68,68,.9); box-shadow: 0 0 0 3px rgba(239,68,68,.16)}
    .dot.work{
      background: rgba(124,58,237,.95);
      box-shadow: 0 0 0 3px rgba(124,58,237,.16);
      animation: pulse 1.1s infinite ease-in-out;
    }
    @keyframes pulse{
      0%{transform:scale(.95); opacity:.7}
      50%{transform:scale(1.12); opacity:1}
      100%{transform:scale(.95); opacity:.7}
    }
    .cards{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:12px;
    }
    @media (max-width: 700px){
      .cards{grid-template-columns:1fr}
    }
    .card{
      background: rgba(17,24,39,.6);
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: 0 12px 26px rgba(0,0,0,.24);
      display:flex;
      flex-direction:column;
      min-height: 170px;
    }
    .thumb{
      position:relative;
      width:100%;
      aspect-ratio: 16/9;
      background: rgba(255,255,255,.04);
    }
    .thumb img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .badge{
      position:absolute;
      left:10px; top:10px;
      padding:6px 8px;
      border-radius: 999px;
      font-size:12px;
      font-weight:700;
      background: rgba(0,0,0,.5);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(6px);
    }
    .body{
      padding:12px 12px 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1 1 auto;
    }
    .h3{
      margin:0;
      font-size:14px;
      line-height:1.35;
      letter-spacing:-.1px;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient: vertical;
      overflow:hidden;
    }
    .meta{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color: var(--muted);
    }
    .desc{
      margin:0;
      color: rgba(229,231,235,.9);
      font-size:12px;
      line-height:1.45;
      display:-webkit-box;
      -webkit-line-clamp:3;
      -webkit-box-orient: vertical;
      overflow:hidden;
    }
    .actions{
      margin-top:auto;
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
    }
    .actions .left{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      color: var(--muted);
      font-size:12px;
    }
    .smallbtn{
      padding:9px 10px;
      border-radius: 12px;
      font-size:12px;
      font-weight:800;
      background: rgba(34,197,94,.92);
    }
    footer{
      margin-top:16px;
      padding:14px;
      color:var(--muted);
      border-top:1px solid rgba(255,255,255,.06);
      font-size:12px;
      line-height:1.55;
    }
    .kicker{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      margin-top:10px;
    }
    .kbox{
      flex:1 1 240px;
      padding:12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(15,23,42,.35);
    }
    .kbox strong{display:block; font-size:12px; color:rgba(229,231,235,.95); margin-bottom:6px}
    .kbox span{font-size:12px; color:var(--muted); line-height:1.45}
    .tiny{
      font-size:11px;
      color: rgba(156,163,175,.95);
      line-height:1.45;
    }
    .divider{height:1px; background: rgba(255,255,255,.06); margin:12px 0}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>AI 필라테스 루틴 검색기</h1>
        <p>몸 상태를 입력하면, YouTube에서 관련 필라테스 영상을 찾아 카드 형태로 보여줘요. (룰 기반 “AI처럼 보이는” 추천 포함)</p>
      </div>
    </header>

    <div class="grid">
      <!-- 좌측: 검색/결과 -->
      <section class="panel" aria-label="검색 패널">
        <div class="panel-head">
          <h2>검색</h2>
          <span class="tiny">YouTube Data API v3</span>
        </div>
        <div class="panel-body">
          <div class="kicker">
            <div class="kbox" id="recommendBox">
              <strong>오늘의 추천 키워드 (랜덤 3개)</strong>
              <span id="recommendList">불러오는 중…</span>
            </div>
            <div class="kbox">
              <strong>입력 분류(룰 기반)</strong>
              <span id="categoryLine">아직 입력이 없어요.</span>
            </div>
          </div>

          <div class="divider"></div>

          <div class="row">
            <div class="field" style="flex: 1 1 360px;">
              <label for="q">오늘 내 상태</label>
              <input id="q" type="text" placeholder="예: 허리가 아파서 허리 위주로 / 거북목 / 전신 스트레칭" autocomplete="off" />
            </div>

            <div class="field" style="flex: 0 0 140px; min-width: 140px;">
              <label for="order">정렬</label>
              <select id="order">
                <option value="relevance">관련성</option>
                <option value="viewCount">조회수</option>
                <option value="date">최신</option>
              </select>
            </div>

            <div class="field" style="flex: 0 0 170px; min-width: 170px;">
              <label for="dur">영상 길이</label>
              <select id="dur">
                <option value="any">전체</option>
                <option value="shortRange">짧게 (5~15분)</option>
                <option value="midRange">중간 (15~30분)</option>
                <option value="longRange">길게 (30분+)</option>
              </select>
            </div>

            <div class="field" style="flex: 0 0 auto; min-width: 140px;">
              <label>&nbsp;</label>
              <button id="searchBtn">검색</button>
            </div>
          </div>

          <div class="row">
            <div class="field" style="flex: 1 1 100%;">
              <label>추천 태그</label>
              <div class="pillbar" id="tagBar" aria-label="추천 태그 버튼들"></div>
            </div>
          </div>

          <div class="row">
            <div class="field" style="flex: 1 1 100%;">
              <label>최근 검색어 (최대 5개)</label>
              <div class="pillbar" id="recentBar"></div>
            </div>
          </div>

          <div class="status" role="status" aria-live="polite">
            <span class="dot" id="statusDot"></span>
            <div>
              <div id="statusTitle" style="font-weight:700; font-size:12px;">대기 중</div>
              <div id="statusText" class="tiny">API 키를 저장하고 검색을 시작하세요.</div>
            </div>
          </div>

          <div class="divider"></div>

          <div id="resultTop" class="note"></div>
          <div id="cards" class="cards" aria-label="검색 결과"></div>

          <footer>
            <strong style="color:rgba(229,231,235,.92)">사용법</strong>
            <ol style="margin:8px 0 0 18px; padding:0;">
              <li>오른쪽 “설정”에서 YouTube API Key를 저장</li>
              <li>“오늘 내 상태”를 입력하고 검색 (예: <em>허리 통증</em>, <em>거북목</em>)</li>
              <li>원하는 길이/정렬로 필터링하고, 영상 보기 버튼으로 새 탭에서 재생</li>
            </ol>
            <div class="tiny" style="margin-top:10px;">
              ⚠️ 참고: <span id="runtimeHint">현재 실행 환경에 맞는 API 키 제한 안내를 자동으로 표시합니다.</span>
            </div>
          </footer>
        </div>
      </section>

      <!-- 우측: 설정 -->
      <aside class="panel" aria-label="설정 패널">
        <div class="panel-head">
          <h2>설정</h2>
          <span class="tiny">API Key 저장/삭제</span>
        </div>
        <div class="panel-body">
          <div class="row">
            <div class="field">
              <label for="apiKey">YouTube API Key</label>
              <input id="apiKey" type="password" placeholder="여기에 API 키를 입력" autocomplete="off" />
              <div class="tiny">저장 시 localStorage에 보관됩니다(브라우저에만 저장).</div>
            </div>
          </div>

          <div class="row">
            <button class="secondary" id="saveKeyBtn">키 저장</button>
            <button class="danger" id="deleteKeyBtn">키 삭제</button>
          </div>

          <div class="status" style="margin-top:12px;">
            <span class="dot" id="keyDot"></span>
            <div>
              <div id="keyTitle" style="font-weight:700; font-size:12px;">키 상태</div>
              <div id="keyText" class="tiny">아직 저장된 키가 없어요.</div>
            </div>
          </div>

          
          <div class="kbox" style="margin:0 0 12px 0;">
            <strong>현재 접속 주소(Origin)</strong>
            <span id="originLine">확인 중…</span>
            <div class="tiny" style="margin-top:8px" id="referrerHint">Referrer 제한 안내를 불러오는 중…</div>
            <div class="row" style="margin-top:10px">
              <button class="secondary" id="copyUrlBtn" type="button">현재 주소 복사</button>
            </div>
          </div>

          <div class="divider"></div>

          <div class="note">

            <b>왜 룰 기반 “AI”인가요?</b><br/>
            복잡한 AI 모델 없이도, “입력 문장 → 카테고리 분류 → 검색어 보정” 규칙을 잘 만들면
            사용자 입장에서는 AI처럼 똑똑하게 느껴질 수 있어요. 발표에서 “규칙(사전)을 계속 학습시키듯 확장 가능”이라고 설명하면 좋아요.
          </div>
        </div>
      </aside>
    </div>
  </div>

<script>
/**
 * ============================================================
 * 1) 룰(사전) 기반 “검색어 보정” + “카테고리 분류” 사전 (JSON)
 *    - 발표 때: "사용자 입력을 규칙으로 해석해 검색 품질을 올린다" 라고 설명 가능
 *    - 필요하면 여기만 계속 추가/수정하면 됨
 * ============================================================
 */

/** 카테고리 분류 키워드(룰 기반) */
const CATEGORY_RULES = [
  { category: "통증", keywords: ["아프", "통증", "결림", "뭉침", "저림", "뻐근", "쑤심", "염좌", "근육통", "디스크", "협착"] },
  { category: "교정", keywords: ["교정", "자세", "거북목", "라운드숄더", "골반", "척추", "체형", "틀어짐", "정렬"] },
  { category: "강화", keywords: ["강화", "근력", "코어", "힙업", "하체", "복근", "탄탄", "밸런스", "안정화"] },
  { category: "스트레칭", keywords: ["스트레칭", "유연", "이완", "풀기", "릴리즈", "가동성", "mobility"] },
  { category: "초보", keywords: ["초보", "입문", "처음", "기초", "초급", "beginners", "beginner"] },
];

/**
 * 검색어 보정 매핑(신체부위/증상 → 추천 검색 키워드)
 * - key: 사용자가 입력에서 포함할 수 있는 단어(부분 일치)
 * - value: YouTube 검색에 더 잘 걸리는 확장 문구
 */
const QUERY_MAP = {
  "허리": ["허리 통증 완화", "허리 안정화 코어", "허리 디스크 운동(저강도)"],
  "목": ["목 통증 스트레칭", "거북목 교정", "목/승모근 이완"],
  "어깨": ["어깨 뭉침 풀기", "라운드숄더 교정", "어깨 가동성 스트레칭"],
  "골반": ["골반 교정", "골반 비틀림 교정", "고관절 스트레칭"],
  "무릎": ["무릎 통증 완화(저충격)", "무릎 주변 근력 강화", "하체 정렬 운동"],
  "손목": ["손목 통증 완화 스트레칭", "손목 보호 운동", "손목 가동성"],
  "거북목": ["거북목 교정 스트레칭", "목/등 상부 자세 교정"],
  "라운드숄더": ["라운드숄더 교정", "등/흉추 스트레칭"],
  "코어": ["코어 강화", "복부 안정화", "필라테스 코어 루틴"],
  "전신": ["전신 스트레칭", "전신 유산소+필라테스", "전신 순환 루틴"],
  "스트레칭": ["스트레칭", "유연성", "전신 이완"],
  "초보": ["초보 필라테스", "기초 필라테스", "쉬운 동작"],
};

/** 추천 태그(버튼) */
const TAGS = [
  { label: "허리", value: "허리" },
  { label: "어깨", value: "어깨" },
  { label: "목", value: "목" },
  { label: "골반", value: "골반" },
  { label: "무릎", value: "무릎" },
  { label: "손목", value: "손목" },
  { label: "전신", value: "전신" },
  { label: "코어", value: "코어" },
  { label: "스트레칭", value: "스트레칭" },
  { label: "초보", value: "초보" },
];

/** 오늘의 추천 키워드 풀(랜덤 3개) */
const RECOMMEND_POOL = [
  { keyword: "허리 통증 완화", reason: "장시간 앉아있는 직장인에게 흔한 불편 포인트예요.", category: "통증" },
  { keyword: "거북목 교정", reason: "스마트폰/노트북 자세로 목·어깨가 쉽게 굳어요.", category: "교정" },
  { keyword: "골반 교정", reason: "좌우 밸런스가 무너지면 허리/무릎까지 영향이 가요.", category: "교정" },
  { keyword: "코어 강화", reason: "필라테스의 핵심! 안정화가 좋아지면 자세가 달라져요.", category: "강화" },
  { keyword: "전신 스트레칭", reason: "짧게라도 전신을 풀어주면 컨디션이 확 달라져요.", category: "스트레칭" },
  { keyword: "초보 필라테스", reason: "처음이면 ‘쉬운 루틴’으로 성공 경험부터 만들어요.", category: "초보" },
  { keyword: "어깨 뭉침 풀기", reason: "승모근 긴장을 낮춰야 상체 움직임이 편해져요.", category: "통증" },
  { keyword: "고관절 스트레칭", reason: "골반 주변이 부드러워지면 동작이 훨씬 좋아져요.", category: "스트레칭" },
];

/**
 * ============================================================
 * 2) localStorage 키
 * ============================================================
 */
const LS_API_KEY = "pilatesYT_apiKey_v1";
const LS_RECENTS = "pilatesYT_recentQueries_v1";

/**
 * ============================================================
 * 3) DOM 헬퍼 (XSS 방지: innerHTML 대신 DOM 생성)
 * ============================================================
 */
function el(tag, props = {}, children = []) {
  const node = document.createElement(tag);
  for (const [k, v] of Object.entries(props)) {
    if (k === "class") node.className = v;
    else if (k === "text") node.textContent = v;
    else if (k === "href") node.setAttribute("href", v);
    else if (k === "target") node.setAttribute("target", v);
    else if (k === "rel") node.setAttribute("rel", v);
    else if (k.startsWith("on") && typeof v === "function") node.addEventListener(k.slice(2), v);
    else node.setAttribute(k, v);
  }
  for (const c of children) node.appendChild(c);
  return node;
}

function fmtDate(iso) {
  try{
    const d = new Date(iso);
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }catch{ return ""; }
}

/** ISO8601 duration(PT#H#M#S) -> seconds */
function parseISO8601DurationToSec(iso) {
  // 예: PT1H2M3S, PT12M, PT45S
  const m = iso.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/);
  if (!m) return null;
  const h = parseInt(m[1] || "0", 10);
  const min = parseInt(m[2] || "0", 10);
  const s = parseInt(m[3] || "0", 10);
  return h*3600 + min*60 + s;
}

function fmtDuration(sec){
  if (sec == null) return "";
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  if (h > 0) return `${h}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  return `${m}:${String(s).padStart(2,"0")}`;
}

function setStatus(kind, title, text){
  const dot = document.getElementById("statusDot");
  const t = document.getElementById("statusTitle");
  const x = document.getElementById("statusText");

  dot.className = "dot";
  if (kind === "ok") dot.classList.add("ok");
  if (kind === "bad") dot.classList.add("bad");
  if (kind === "work") dot.classList.add("work");

  t.textContent = title;
  x.textContent = text;
}

function setKeyStatus(kind, title, text){
  const dot = document.getElementById("keyDot");
  const t = document.getElementById("keyTitle");
  const x = document.getElementById("keyText");

  dot.className = "dot";
  if (kind === "ok") dot.classList.add("ok");
  if (kind === "bad") dot.classList.add("bad");

  t.textContent = title;
  x.textContent = text;
}

/**
 * ============================================================
 * 4) 추천 키워드(랜덤 3개) 렌더
 * ============================================================
 */
function renderTodayRecs(){
  // 매 새로고침마다 랜덤도 괜찮지만, "오늘" 느낌을 위해 날짜 기반 시드 비슷하게 구현
  const today = new Date();
  const seed = today.getFullYear()*10000 + (today.getMonth()+1)*100 + today.getDate();
  let idx = seed % 9973;

  function nextRand(){
    // 아주 단순한 의사난수(재현성 확보용)
    idx = (idx * 9301 + 49297) % 233280;
    return idx / 233280;
  }

  const pool = [...RECOMMEND_POOL];
  const picked = [];
  while (picked.length < 3 && pool.length > 0){
    const r = Math.floor(nextRand() * pool.length);
    picked.push(pool.splice(r,1)[0]);
  }

  const box = document.getElementById("recommendList");
  box.textContent = ""; // 초기화
  const wrap = el("div", { class: "pillbar" });

  for (const p of picked){
    const pill = el("div", { class:"pill", title: "클릭해서 바로 검색" }, [el("span", { text: p.keyword })]);
    pill.addEventListener("click", () => {
      document.getElementById("q").value = p.keyword;
      updateCategoryLine(p.keyword);
      doSearch();
    });
    wrap.appendChild(pill);

    // 이유 한 줄
    const reason = el("div", { class: "tiny", text: `• ${p.keyword} — ${p.reason}` });
    const line = el("div", {});
    line.appendChild(reason);
    box.appendChild(line);
  }
  // box에 이유를 여러 줄로 쌓는 구조라 wrap 사용 안함. (요구사항: 이유 한 줄)
}
renderTodayRecs();

/**
 * ============================================================
 * 5) 최근 검색어(localStorage) 관리
 * ============================================================
 */
function loadRecents(){
  try{
    const raw = localStorage.getItem(LS_RECENTS);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  }catch{
    return [];
  }
}

function saveRecent(q){
  const qq = (q || "").trim();
  if (!qq) return;
  const arr = loadRecents();
  const filtered = arr.filter(x => x !== qq);
  filtered.unshift(qq);
  const next = filtered.slice(0, 5);
  localStorage.setItem(LS_RECENTS, JSON.stringify(next));
  renderRecents();
}

function renderRecents(){
  const bar = document.getElementById("recentBar");
  bar.textContent = "";
  const arr = loadRecents();
  if (arr.length === 0){
    bar.appendChild(el("span", { class:"tiny", text:"아직 검색 기록이 없어요." }));
    return;
  }
  for (const q of arr){
    const b = el("div", { class:"pill", title:"클릭해서 다시 검색" }, [el("span", { text:q })]);
    b.addEventListener("click", () => {
      document.getElementById("q").value = q;
      updateCategoryLine(q);
      doSearch();
    });
    bar.appendChild(b);
  }
}

/**
 * ============================================================
 * 6) 추천 태그 렌더
 * ============================================================
 */
function renderTags(){
  const bar = document.getElementById("tagBar");
  bar.textContent = "";
  for (const t of TAGS){
    const p = el("div", { class:"pill" }, [el("span", { text:t.label })]);
    p.addEventListener("click", () => {
      // 입력창에 태그를 자연스럽게 추가
      const input = document.getElementById("q");
      const cur = input.value.trim();
      if (!cur) input.value = t.value;
      else if (!cur.includes(t.value)) input.value = cur + " " + t.value;
      updateCategoryLine(input.value);
      // 시각적으로 토글 느낌
      p.classList.add("on");
      setTimeout(() => p.classList.remove("on"), 180);
      input.focus();
    });
    bar.appendChild(p);
  }
}

/**
 * ============================================================
 * 7) API 키 저장/로드/삭제
 * ============================================================
 */
function loadApiKey(){
  const k = localStorage.getItem(LS_API_KEY);
  return (k || "").trim();
}

function renderKeyState(){
  const k = loadApiKey();
  const keyInput = document.getElementById("apiKey");
  if (k){
    // 보안상 전체를 보여주지 않고 마스킹 느낌만
    keyInput.value = k;
    setKeyStatus("ok", "키 저장됨", "이 브라우저에 API 키가 저장되어 있어요.");
  }else{
    keyInput.value = "";
    setKeyStatus("bad", "키 없음", "API 키를 입력하고 저장해 주세요.");
  }
}

document.getElementById("saveKeyBtn").addEventListener("click", () => {
  const v = document.getElementById("apiKey").value.trim();
  if (!v){
    setKeyStatus("bad", "저장 실패", "빈 값은 저장할 수 없어요.");
    return;
  }
  localStorage.setItem(LS_API_KEY, v);
  renderKeyState();
  setStatus("ok", "준비 완료", "이제 검색할 수 있어요.");
});

document.getElementById("deleteKeyBtn").addEventListener("click", () => {
  localStorage.removeItem(LS_API_KEY);
  renderKeyState();
  setStatus("bad", "키가 삭제됨", "검색하려면 다시 키를 저장해 주세요.");
});

renderKeyState();
renderTags();
renderRecents();

/**
 * ============================================================
 * 8) 카테고리 분류(룰 기반) + 검색어 보정
 * ============================================================
 */
function classifyCategory(input){
  const s = (input || "").toLowerCase();
  for (const r of CATEGORY_RULES){
    for (const kw of r.keywords){
      if (s.includes(kw.toLowerCase())) return r.category;
    }
  }
  // 기본값: 입력이 없거나 애매하면 스트레칭으로 유도
  return s.trim() ? "스트레칭" : null;
}

function categoryMessage(category){
  if (!category) return "아직 입력이 없어요.";
  switch(category){
    case "통증": return "통증/불편이 느껴지면 ‘저강도·완화·이완’ 중심으로 추천해요.";
    case "교정": return "자세·체형은 ‘교정/정렬/흉추·고관절 가동성’ 키워드가 잘 맞아요.";
    case "강화": return "근력/코어는 ‘안정화·코어 강화·밸런스’ 루틴이 효과적이에요.";
    case "스트레칭": return "뭉침/굳음이 있으면 ‘스트레칭·이완·가동성’으로 추천해요.";
    case "초보": return "처음이면 ‘기초·쉬운 동작·짧은 루틴’으로 시작해요.";
    default: return "입력에 맞춰 추천 문구를 구성했어요.";
  }
}

function updateCategoryLine(input){
  const c = classifyCategory(input);
  const line = document.getElementById("categoryLine");
  if (!c){
    line.textContent = "아직 입력이 없어요.";
    return;
  }
  line.textContent = `분류: ${c} · ${categoryMessage(c)}`;
}

function buildSmartQuery(userInput){
  const raw = (userInput || "").trim();
  const category = classifyCategory(raw);

  // 기본적으로 "필라테스/pilates"를 붙임
  const baseTokens = [];
  if (raw) baseTokens.push(raw);

  // 룰 기반 매핑으로 확장 문구 추가
  // (입력에 포함된 키를 발견하면 대표 추천 문구 1~2개를 추가)
  const expansions = [];
  for (const [key, values] of Object.entries(QUERY_MAP)){
    if (raw.includes(key)){
      // 가장 대표적인 1개만 우선
      if (values && values.length) expansions.push(values[0]);
    }
  }

  // 카테고리별로 보정 키워드 가산
  const categoryBoost = {
    "통증": ["완화", "저강도", "스트레칭"],
    "교정": ["교정", "자세", "정렬"],
    "강화": ["강화", "코어", "안정화"],
    "스트레칭": ["스트레칭", "이완", "가동성"],
    "초보": ["초보", "기초", "쉬운"],
  };

  const boosts = category ? (categoryBoost[category] || []) : [];
  // 최종 쿼리 구성: 사용자 입력 + 확장 + 부스트 + 필라테스
  const pieces = [];

  if (raw) pieces.push(raw);
  for (const e of expansions.slice(0, 2)) pieces.push(e);
  for (const b of boosts.slice(0, 2)) pieces.push(b);

  // "필라테스" + "pilates" 둘 다 넣으면 검색 폭이 넓어짐
  pieces.push("필라테스");
  pieces.push("pilates");

  // 중복 제거
  const dedup = [];
  for (const p of pieces){
    const t = (p || "").trim();
    if (!t) continue;
    if (!dedup.includes(t)) dedup.push(t);
  }

  return { query: dedup.join(" "), category };
}

/**
 * ============================================================
 * 9) YouTube Data API v3 호출
 *    - search.list 로 영상ID 목록을 얻고
 *    - videos.list 로 duration/snippet 를 가져옴 (길이 필터 위해 필요)
 * ============================================================
 */
const YT_BASE = "https://www.googleapis.com/youtube/v3";

function buildUrl(path, params){
  const u = new URL(YT_BASE + path);
  for (const [k,v] of Object.entries(params)){
    u.searchParams.set(k, String(v));
  }
  return u.toString();
}

async function ytSearch(apiKey, q, order){
  const url = buildUrl("/search", {
    part: "snippet",
    q,
    type: "video",
    maxResults: 15,
    order,
    safeSearch: "strict",
    key: apiKey
  });

  const res = await fetch(url);
  const data = await res.json();
  if (!res.ok){
    const msg = (data && data.error && data.error.message) ? data.error.message : "요청 실패";
    const reason = (data && data.error && data.error.errors && data.error.errors[0] && data.error.errors[0].reason) ? data.error.errors[0].reason : "unknown";
    throw new Error(`${msg} (reason: ${reason})`);
  }
  const ids = (data.items || [])
    .map(it => it.id && it.id.videoId)
    .filter(Boolean);
  return ids;
}

async function ytVideos(apiKey, ids){
  if (!ids.length) return [];
  const url = buildUrl("/videos", {
    part: "snippet,contentDetails",
    id: ids.join(","),
    key: apiKey
  });

  const res = await fetch(url);
  const data = await res.json();
  if (!res.ok){
    const msg = (data && data.error && data.error.message) ? data.error.message : "요청 실패";
    const reason = (data && data.error && data.error.errors && data.error.errors[0] && data.error.errors[0].reason) ? data.error.errors[0].reason : "unknown";
    throw new Error(`${msg} (reason: ${reason})`);
  }
  return data.items || [];
}

/**
 * 길이 필터: (5~15), (15~30), (30+)
 */
function filterByDuration(items, mode){
  if (mode === "any") return items;

  const min5 = 5 * 60;
  const min15 = 15 * 60;
  const min30 = 30 * 60;

  return items.filter(it => {
    const sec = parseISO8601DurationToSec(it.contentDetails && it.contentDetails.duration);
    if (sec == null) return false;
    if (mode === "shortRange") return sec >= min5 && sec < min15;
    if (mode === "midRange") return sec >= min15 && sec < min30;
    if (mode === "longRange") return sec >= min30;
    return true;
  });
}

/**
 * ============================================================
 * 10) 결과 렌더링
 * ============================================================
 */
function clearResults(){
  document.getElementById("cards").textContent = "";
  document.getElementById("resultTop").textContent = "";
}

function renderResults(items, info){
  const cards = document.getElementById("cards");
  cards.textContent = "";

  const top = document.getElementById("resultTop");
  top.textContent = info;

  if (!items.length){
    cards.appendChild(el("div", { class:"note", text:"조건에 맞는 결과가 없어요. 다른 키워드로 다시 시도해보세요." }));
    return;
  }

  for (const it of items){
    const sn = it.snippet || {};
    const title = sn.title || "";
    const channel = sn.channelTitle || "";
    const publishedAt = sn.publishedAt ? fmtDate(sn.publishedAt) : "";
    const desc = sn.description || "";
    const thumbUrl = (sn.thumbnails && (sn.thumbnails.medium || sn.thumbnails.high || sn.thumbnails.default) && (sn.thumbnails.medium || sn.thumbnails.high || sn.thumbnails.default).url) || "";
    const vid = it.id;
    const durSec = parseISO8601DurationToSec(it.contentDetails && it.contentDetails.duration);
    const durText = durSec != null ? fmtDuration(durSec) : "";

    const card = el("div", { class:"card" });

    const thumb = el("div", { class:"thumb" });
    if (thumbUrl){
      const img = el("img", { src: thumbUrl, alt: title });
      thumb.appendChild(img);
    }
    if (durText){
      thumb.appendChild(el("div", { class:"badge", text: durText }));
    }

    const body = el("div", { class:"body" });
    body.appendChild(el("h3", { class:"h3", text: title }));

    // 요구사항: 채널명 + 업로드일 반드시 표시
    const meta = el("div", { class:"meta" });
    meta.appendChild(el("span", { text: `채널: ${channel}` }));
    if (publishedAt) meta.appendChild(el("span", { text: `업로드: ${publishedAt}` }));
    body.appendChild(meta);

    if (desc){
      body.appendChild(el("p", { class:"desc", text: desc }));
    }

    const actions = el("div", { class:"actions" });
    const left = el("div", { class:"left" });
    left.appendChild(el("span", { text: "YouTube" }));
    actions.appendChild(left);

    const btn = el("button", { class:"smallbtn", text:"영상 보기" });
    btn.addEventListener("click", () => {
      const url = `https://www.youtube.com/watch?v=${encodeURIComponent(vid)}`;
      window.open(url, "_blank", "noopener,noreferrer");
    });
    actions.appendChild(btn);

    body.appendChild(actions);

    card.appendChild(thumb);
    card.appendChild(body);
    cards.appendChild(card);
  }
}

/**
 * ============================================================
 * 11) 메인 검색 함수
 * ============================================================
 */
async function doSearch(){
  const apiKey = loadApiKey();
  if (!apiKey){
    setStatus("bad", "API 키가 필요해요", "오른쪽 설정에서 API 키를 저장한 뒤 검색해 주세요.");
    return;
  }

  const userInput = document.getElementById("q").value.trim();
  if (!userInput){
    setStatus("bad", "입력을 확인해요", "검색할 몸 상태(키워드)를 입력해 주세요.");
    return;
  }

  updateCategoryLine(userInput);

  const order = document.getElementById("order").value;
  const durMode = document.getElementById("dur").value;

  const { query, category } = buildSmartQuery(userInput);
  const infoLine = `검색어(보정됨): “${query}” · 분류: ${category}`;

  setStatus("work", "검색 중…", "YouTube에서 영상을 찾고 있어요.");
  clearResults();

  try{
    const ids = await ytSearch(apiKey, query, order);
    if (!ids.length){
      setStatus("ok", "완료", "검색 결과가 없어요. 다른 키워드로 시도해 보세요.");
      renderResults([], infoLine);
      return;
    }

    const vids = await ytVideos(apiKey, ids);
    // 길이 필터(정밀)
    const filtered = filterByDuration(vids, durMode);

    // 최근 검색어 저장(사용자 입력 기준)
    saveRecent(userInput);

    setStatus("ok", "완료", `결과 ${filtered.length}개를 표시했어요.`);
    renderResults(filtered, infoLine);
  }catch(err){
    const msg = String(err && err.message ? err.message : err);
    // 자주 발생하는 이유를 친절하게 안내
    let hint = "오류가 발생했어요.";
    if (msg.includes("quotaExceeded")) hint = "일일 쿼터를 초과했어요(quotaExceeded). 내일 다시 시도하거나 새 프로젝트/키를 사용해 보세요.";
    else if (msg.includes("keyInvalid")) hint = "API 키가 잘못되었어요(keyInvalid). 키를 다시 확인해 주세요.";
    else if (msg.includes("forbidden") || msg.includes("accessNotConfigured")) hint = "API가 비활성화되었거나 접근이 막혔어요. Google Cloud Console에서 YouTube Data API v3 활성화 여부를 확인해 주세요.";
    else if (msg.includes("API key not valid") || msg.includes("PERMISSION_DENIED")) hint = "키 제한(리퍼러/도메인 제한) 때문에 막혔을 수 있어요. 더블클릭(file://) 실행이라면 키 제한을 풀거나 localhost에서 열어보세요.";
    setStatus("bad", "실패", hint);
    document.getElementById("resultTop").textContent = `에러 상세: ${msg}`;
  }
}

document.getElementById("searchBtn").addEventListener("click", doSearch);
document.getElementById("q").addEventListener("keydown", (e) => {
  if (e.key === "Enter"){
    e.preventDefault();
    doSearch();
  }
});
document.getElementById("q").addEventListener("input", (e) => updateCategoryLine(e.target.value));


/**
 * ============================================================
 * 12) 실행 환경(Origin) 표시 + Referrer 제한 안내(자동)
 *    - GitHub Pages 배포 시: https://아이디.github.io/저장소/ 형태를 감지해
 *      추천 Referrer 패턴을 안내합니다.
 * ============================================================
 */
function computeOriginInfo(){
  // file:// 에서는 location.origin이 "null" (문자열)로 나오는 경우가 많습니다.
  const origin = location.origin;
  const href = location.href;
  const host = location.host || "";
  const pathname = location.pathname || "";

  const isFile = (origin === "null") || href.startsWith("file:");
  const isLocalhost = /^localhost(:\d+)?$/i.test(host) || /^127\.0\.0\.1(:\d+)?$/.test(host);
  const isGitHubPages = host.endsWith("github.io");

  // GitHub Pages 프로젝트 사이트: https://user.github.io/repo/...
  let repoName = "";
  if (isGitHubPages){
    const parts = pathname.split("/").filter(Boolean); // ["repo", ...]
    if (parts.length >= 1) repoName = parts[0];
  }

  // 추천 referrer 패턴 생성
  const hints = [];
  if (isFile){
    hints.push("현재는 file:// 로 실행 중이라, HTTP referrer 제한을 걸면 API 호출이 막힐 수 있어요.");
    hints.push("권장: (1) 키 제한을 잠깐 해제하거나 (2) Live Server로 http://localhost 에서 열어주세요.");
  } else if (isLocalhost){
    hints.push("현재는 로컬 서버(http://localhost)로 실행 중이에요.");
    hints.push("Referrer 제한을 쓴다면, 허용 항목에 다음을 추가해 보세요:");
    hints.push(`- ${origin}/*`);
  } else if (isGitHubPages){
    hints.push("현재는 GitHub Pages(https://…github.io)에서 실행 중이에요.");
    hints.push("Referrer 제한을 쓴다면, 허용 항목에 아래 패턴을 추가하면 안전하게 쓸 수 있어요:");
    if (repoName){
      hints.push(`- ${origin}/${repoName}/*  (프로젝트 저장소 기준)`);
    } else {
      hints.push(`- ${origin}/*`);
    }
    hints.push("TIP: 설정을 바꾼 뒤 반영까지 1~5분 정도 걸릴 수 있어요.");
  } else {
    hints.push("현재는 일반 웹 주소(https://…)에서 실행 중이에요.");
    hints.push("Referrer 제한을 쓴다면, 허용 항목에 현재 사이트 주소 패턴을 추가하세요:");
    hints.push(`- ${origin}/*`);
  }

  return {
    origin,
    href,
    isFile,
    isLocalhost,
    isGitHubPages,
    repoName,
    hints
  };
}

function renderOriginInfo(){
  const info = computeOriginInfo();

  const originLine = document.getElementById("originLine");
  const referrerHint = document.getElementById("referrerHint");
  const runtimeHint = document.getElementById("runtimeHint");

  if (originLine){
    // origin이 "null"이면 사용자에게 보기 좋게 표기
    const shown = (info.isFile ? "file:// (로컬 파일 실행)" : info.origin);
    originLine.textContent = `Origin: ${shown}`;
  }

  const lines = info.hints.map(t => `• ${t}`).join("\n");
  if (referrerHint){
    referrerHint.textContent = "";
    // 줄바꿈이 보이도록 white-space 설정 대신 <br> 없이 여러 span으로 구성
    const frag = document.createDocumentFragment();
    info.hints.forEach((t) => {
      frag.appendChild(el("div", { class:"tiny", text:`• ${t}` }));
    });
    referrerHint.appendChild(frag);
  }

  if (runtimeHint){
    // footer 안내(짧게)
    if (info.isFile) runtimeHint.textContent = "file:// 실행 중이면 Referrer 제한이 막힐 수 있어요. Live Server(또는 localhost)로 여는 것을 권장합니다.";
    else if (info.isGitHubPages && info.repoName) runtimeHint.textContent = `GitHub Pages라면 Referrer 허용에 “${info.origin}/${info.repoName}/*” 를 추가하는 것을 권장합니다.`;
    else runtimeHint.textContent = `Referrer 제한을 쓴다면 “${info.origin}/*” 를 허용 목록에 추가하세요.`;
  }

  const copyBtn = document.getElementById("copyUrlBtn");
  if (copyBtn){
    copyBtn.onclick = async () => {
      try{
        // file:// 이면 모바일 공유 가치가 낮으니 href를 복사하되 안내
        await navigator.clipboard.writeText(info.href);
        setStatus("ok", "복사 완료", "현재 주소를 클립보드에 복사했어요.");
      }catch{
        // clipboard 권한이 없으면 fallback
        const ta = document.createElement("textarea");
        ta.value = info.href;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        setStatus("ok", "복사 완료", "현재 주소를 복사했어요.");
      }
    };
  }
}

/** 첫 상태 안내 */
(function init(){
  renderOriginInfo();
  const hasKey = !!loadApiKey();
  if (hasKey){
    setStatus("ok", "준비 완료", "검색할 키워드를 입력하고 Enter를 눌러보세요.");
  }else{
    setStatus("bad", "API 키 필요", "오른쪽 설정에서 YouTube API Key를 저장하세요.");
  }
})();
</script>
</body>
</html>
